// Generated by CoffeeScript 1.3.3
(function() {
  var EventEmitter, IRC, arrayBuffer2String, assert, concatSocketData, emptySocketData, exports, fromSocketData, makeCommand, nicksEqual, normaliseNick, parseCommand, parsePrefix, randomName, string2ArrayBuffer, toSocketData,
    __slice = [].slice,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __hasProp = {}.hasOwnProperty,
    __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

  if (typeof exports === "undefined" || exports === null) {
    exports = window.irc = {};
  }

  parseCommand = function(data) {
    var parts, str;
    str = data.toString('utf8');
    parts = /^(?::([^\x20]+?)\x20)?([^\x20]+?)((?:\x20[^\x20:][^\x20]*)+)?(?:\x20:(.*))?$/.exec(str);
    if (!parts) {
      throw new Error("invalid IRC message: " + data);
    }
    if (parts[3] != null) {
      parts[3] = parts[3].slice(1).split(/\x20/);
    } else {
      parts[3] = [];
    }
    if (parts[4] != null) {
      parts[3].push(parts[4]);
    }
    return {
      prefix: parts[1],
      command: parts[2],
      params: parts[3]
    };
  };

  parsePrefix = function(prefix) {
    var p;
    p = /^([^!]+?)(?:!(.+?)(?:@(.+?))?)?$/.exec(prefix);
    return {
      nick: p[1],
      user: p[2],
      host: p[3]
    };
  };

  exports.parseCommand = parseCommand;

  makeCommand = function() {
    var cmd, params, _params;
    cmd = arguments[0], params = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
    _params = (function() {
      if (params && params.length > 0) {
        if (!params.slice(0, params.length - 1).every(function(a) {
          return !/^:|\x20/.test(a);
        })) {
          throw new Error("some non-final arguments had spaces or initial colons in them");
        }
        if (/^:|\x20/.test(params[params.length - 1])) {
          params[params.length - 1] = ':' + params[params.length - 1];
        }
        return ' ' + params.join(' ');
      } else {
        return '';
      }
    })();
    return cmd + _params + "\x0d\x0a";
  };

  randomName = function(length) {
    var chars, x;
    if (length == null) {
      length = 10;
    }
    chars = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";
    return ((function() {
      var _i, _results;
      _results = [];
      for (x = _i = 0; 0 <= length ? _i < length : _i > length; x = 0 <= length ? ++_i : --_i) {
        _results.push(chars[Math.floor(Math.random() * chars.length)]);
      }
      return _results;
    })()).join('');
  };

  normaliseNick = function(nick) {
    return nick.toLowerCase().replace(/[\[\]\\]/g, function(x) {
      return {
        '[': '{',
        ']': '}',
        '|': '\\'
      }[x];
    });
  };

  nicksEqual = function(a, b) {
    return normaliseNick(a) === normaliseNick(b);
  };

  string2ArrayBuffer = function(string, callback) {
    var blob, f;
    blob = new Blob([string]);
    f = new FileReader();
    f.onload = function(e) {
      return callback(e.target.result);
    };
    return f.readAsArrayBuffer(blob);
  };

  arrayBuffer2String = function(buf, callback) {
    var blob, f;
    blob = new Blob([new DataView(buf)]);
    f = new FileReader();
    f.onload = function(e) {
      return callback(e.target.result);
    };
    return f.readAsText(blob);
  };

  toSocketData = function(str, cb) {
    return string2ArrayBuffer(str, function(ab) {
      return cb(ab);
    });
  };

  fromSocketData = function(ab, cb) {
    console.log(ab);
    return arrayBuffer2String(ab, cb);
  };

  emptySocketData = function() {
    return new ArrayBuffer(0);
  };

  concatSocketData = function(a, b) {
    var result, resultView;
    result = new ArrayBuffer(a.byteLength + b.byteLength);
    resultView = new Uint8Array(result);
    resultView.set(new Uint8Array(a));
    resultView.set(new Uint8Array(b), a.byteLength);
    return result;
  };

  EventEmitter = (function() {

    function EventEmitter() {}

    EventEmitter.prototype.on = function(ev, cb) {
      var _base, _ref, _ref1;
      if ((_ref = this._listeners) == null) {
        this._listeners = {};
      }
      return ((_ref1 = (_base = this._listeners)[ev]) != null ? _ref1 : _base[ev] = []).push(cb);
    };

    EventEmitter.prototype.emit = function() {
      var args, ev, l, _i, _len, _ref, _ref1, _ref2, _results;
      ev = arguments[0], args = 2 <= arguments.length ? __slice.call(arguments, 1) : [];
      if ((_ref = this._listeners) == null) {
        this._listeners = {};
      }
      _ref2 = (_ref1 = this._listeners[ev]) != null ? _ref1 : [];
      _results = [];
      for (_i = 0, _len = _ref2.length; _i < _len; _i++) {
        l = _ref2[_i];
        _results.push(l.apply(null, args));
      }
      return _results;
    };

    return EventEmitter;

  })();

  assert = function(cond) {
    if (!cond) {
      throw new Error("assertion failed");
    }
  };

  IRC = (function(_super) {
    var handlers;

    __extends(IRC, _super);

    function IRC(server, port, opts) {
      var _base, _ref, _ref1,
        _this = this;
      this.server = server;
      this.port = port;
      this.opts = opts;
      this.reconnect = __bind(this.reconnect, this);

      this.onTimeout = __bind(this.onTimeout, this);

      if ((_ref = this.opts) == null) {
        this.opts = {};
      }
      if ((_ref1 = (_base = this.opts).nick) == null) {
        _base.nick = "irc5-" + (randomName());
      }
      this.socket = new net.Socket;
      this.socket.on('connect', function() {
        return _this.onConnect();
      });
      this.socket.on('data', function(data) {
        return _this.onData(data);
      });
      this.socket.on('error', function(err) {
        return _this.onError(err);
      });
      this.socket.on('end', function(err) {
        return _this.onEnd(err);
      });
      this.socket.on('close', function(err) {
        return _this.onClose(err);
      });
      this.data = emptySocketData();
      this.partialNameLists = {};
      this.channels = {};
      this.state = 'disconnected';
    }

    IRC.prototype.connect = function() {
      var _ref;
      assert((_ref = this.state) === 'disconnected' || _ref === 'reconnecting');
      if (this.reconnect_timer) {
        clearTimeout(this.reconnect_timer);
      }
      this.reconnect_timer = null;
      this.socket.connect(this.port, this.server);
      return this.state = 'connecting';
    };

    IRC.prototype.quit = function(reason) {
      assert(this.state === 'connected');
      this.send('QUIT', reason);
      return this.state = 'disconnected';
    };

    IRC.prototype.giveup = function() {
      assert(this.state === 'reconnecting');
      clearTimeout(this.reconnect_timer);
      this.reconnect_timer = null;
      return this.state = 'disconnected';
    };

    IRC.prototype.onConnect = function() {
      if (this.opts.password) {
        this._send('PASS', this.opts.password);
      }
      this._send('NICK', this.opts.nick);
      this._send('USER', this.opts.nick, '0', '*', 'An irc5 user');
      return this.socket.setTimeout(60000, this.onTimeout);
    };

    IRC.prototype.onTimeout = function() {
      this.send('PING', +(new Date));
      return this.socket.setTimeout(60000, this.onTimeout);
    };

    IRC.prototype.onError = function(err) {
      console.error("socket error", err);
      this.setReconnect();
      return this.socket.end();
    };

    IRC.prototype.onClose = function() {
      this.socket.setTimeout(0, this.onTimeout);
      this.emit('disconnect');
      if (this.state === 'connected') {
        return this.setReconnect();
      }
    };

    IRC.prototype.onEnd = function() {
      console.error("remote peer closed connection");
      if (this.state === 'connected') {
        return this.setReconnect();
      }
    };

    IRC.prototype.setReconnect = function() {
      this.state = 'reconnecting';
      return this.reconnect_timer = setTimeout(this.reconnect, 10000);
    };

    IRC.prototype.reconnect = function() {
      return this.connect();
    };

    IRC.prototype.onData = function(pdata) {
      var cr, crlf, d, dataView, i, line, _i, _len, _results,
        _this = this;
      this.data = concatSocketData(this.data, pdata);
      dataView = new Uint8Array(this.data);
      _results = [];
      while (dataView.length > 0) {
        cr = false;
        crlf = void 0;
        for (i = _i = 0, _len = dataView.length; _i < _len; i = ++_i) {
          d = dataView[i];
          if (d === 0x0d) {
            cr = true;
          } else if (cr && d === 0x0a) {
            crlf = i;
            break;
          } else {
            cr = false;
          }
        }
        if (crlf != null) {
          line = this.data.slice(0, crlf - 1);
          this.data = this.data.slice(crlf + 1);
          dataView = new Uint8Array(this.data);
          _results.push(fromSocketData(line, function(lineStr) {
            console.log('<=', lineStr);
            return _this.onCommand(parseCommand(lineStr));
          }));
        } else {
          break;
        }
      }
      return _results;
    };

    IRC.prototype._send = function() {
      var args, msg,
        _this = this;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      msg = makeCommand.apply(null, args);
      console.log('=>', msg.slice(0, msg.length - 2));
      return toSocketData(msg, function(arr) {
        return _this.socket.write(arr);
      });
    };

    IRC.prototype.send = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.state !== 'connected') {
        return;
      }
      return this._send.apply(this, args);
    };

    IRC.prototype.onCommand = function(cmd) {
      if (/^\d{3}$/.test(cmd.command)) {
        cmd.command = parseInt(cmd.command, 10);
      }
      if (handlers[cmd.command]) {
        return handlers[cmd.command].apply(this, [parsePrefix(cmd.prefix)].concat(cmd.params));
      } else {
        return this.emit('message', void 0, 'unknown', cmd);
      }
    };

    handlers = {
      1: function(from, target, msg) {
        var c, name, _ref, _results;
        this.nick = target;
        this.emit('connect');
        this.state = 'connected';
        this.emit('message', void 0, 'welcome', msg);
        _ref = this.channels;
        _results = [];
        for (name in _ref) {
          c = _ref[name];
          _results.push(this.send('JOIN', name));
        }
        return _results;
      },
      353: function(from, target, privacy, channel, names) {
        var l, n, _base, _i, _len, _ref, _results;
        l = ((_base = this.partialNameLists)[channel] || (_base[channel] = {}));
        _ref = names.split(/\x20/);
        _results = [];
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          n = _ref[_i];
          n = n.replace(/^[@+]/, '');
          _results.push(l[normaliseNick(n)] = n);
        }
        return _results;
      },
      366: function(from, target, channel, _) {
        if (this.channels[channel]) {
          this.channels[channel].names = this.partialNameLists[channel];
        } else {
          console.warn("Got name list for " + channel + ", but we're not in it?");
        }
        return delete this.partialNameLists[channel];
      },
      NICK: function(from, newNick, msg) {
        var chan, name, new_norm_nick, norm_nick, _ref, _results;
        if (nicksEqual(from.nick, this.nick)) {
          this.nick = newNick;
        }
        norm_nick = normaliseNick(from.nick);
        new_norm_nick = normaliseNick(newNick);
        _ref = this.channels;
        _results = [];
        for (name in _ref) {
          chan = _ref[name];
          if (!(norm_nick in chan.names)) {
            continue;
          }
          delete chan.names[norm_nick];
          chan.names[new_norm_nick] = newNick;
          _results.push(this.emit('message', chan, 'nick', from.nick, newNick));
        }
        return _results;
      },
      JOIN: function(from, chan) {
        var c;
        if (nicksEqual(from.nick, this.nick)) {
          if (c = this.channels[chan]) {
            c.names = [];
          } else {
            this.channels[chan] = {
              names: []
            };
          }
          this.emit('joined', chan);
        }
        if (c = this.channels[chan]) {
          c.names[normaliseNick(from.nick)] = from.nick;
          return this.emit('message', chan, 'join', from.nick);
        } else {
          return console.warn("Got JOIN for channel we're not in (" + channel + ")");
        }
      },
      PART: function(from, chan) {
        var c, _ref;
        if (c = this.channels[chan]) {
          delete c.names[normaliseNick(from.nick)];
          this.emit('message', chan, 'part', from.nick);
        } else {
          console.warn("Got PART for channel we're not in (" + channel + ")");
        }
        if (nicksEqual(from.nick, this.nick)) {
          if ((_ref = this.channels[chan]) != null) {
            _ref.names = [];
          }
          return this.emit('parted', chan);
        }
      },
      QUIT: function(from, reason) {
        var chan, name, norm_nick, _ref, _results;
        norm_nick = normaliseNick(from.nick);
        _ref = this.channels;
        _results = [];
        for (name in _ref) {
          chan = _ref[name];
          if (!(norm_nick in chan.names)) {
            continue;
          }
          delete chan.names[norm_nick];
          _results.push(this.emit('message', chan, 'quit', from.nick));
        }
        return _results;
      },
      PRIVMSG: function(from, target, msg) {
        return this.emit('message', target, 'privmsg', from.nick, msg);
      },
      PING: function(from, payload) {
        return this.send('PONG', payload);
      },
      PONG: function(from, payload) {},
      433: function(from, nick, msg) {
        this.opts.nick += '_';
        this.emit('message', void 0, 'nickinuse', nick, this.opts.nick, msg);
        return this._send('NICK', this.opts.nick);
      }
    };

    return IRC;

  })(EventEmitter);

  exports.IRC = IRC;

}).call(this);
