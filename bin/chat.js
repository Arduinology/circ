// Generated by CoffeeScript 1.3.3
(function() {
  var $cmd, IRC5, Window, display, escapeHTML, irc5,
    __bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    __slice = [].slice;

  escapeHTML = function(html) {
    var escaped;
    escaped = {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;'
    };
    return String(html).replace(/[&<>"]/g, function(chr) {
      return escaped[chr];
    });
  };

  display = function(text) {
    var canonicalise, escape, m, res, rurl, textIndex;
    rurl = /\b((?:[a-z][\w-]+:(?:\/{1,3}|[a-z0-9%])|www\d{0,3}[.]|[a-z0-9.\-]+[.][a-z]{2,4}\/)(?:[^\s()<>]+|\(([^\s()<>]+|(\([^\s()<>]+\)))*\))+(?:\(([^\s()<>]+|(\([^\s()<>]+\)))*\)|[^\s`!()\[\]{};:'".,<>?«»“”‘’]))/gi;
    canonicalise = function(url) {
      url = escapeHTML(url);
      if (url.match(/^[a-z][\w-]+:/i)) {
        return url;
      } else {
        return 'http://' + url;
      }
    };
    escape = function(str) {
      return escapeHTML(str).replace(/\S{40,}/, '<span class="longword">$&</span>');
    };
    res = '';
    textIndex = 0;
    while (m = rurl.exec(text)) {
      res += escape(text.substr(textIndex, m.index - textIndex));
      res += '<a target="_blank" href="' + canonicalise(m[0]) + '">' + escape(m[0]) + '</a>';
      textIndex = m.index + m[0].length;
    }
    res += escape(text.substr(textIndex));
    return res;
  };

  IRC5 = (function() {
    var commands, handlers, system_handlers;

    function IRC5() {
      this.onMessage = __bind(this.onMessage, this);

      var _this = this;
      this.$main = $('#main');
      this.default_nick = void 0;
      chrome.storage.sync.get('nick', function(settings) {
        if (settings != null ? settings.nick : void 0) {
          return _this.default_nick = settings.nick;
        }
      });
      this.systemWindow = new Window('system');
      this.switchToWindow(this.systemWindow);
      this.winList = [this.systemWindow];
      this.systemWindow.message('', "Welcome to irciii, a v2 Chrome app.");
      this.systemWindow.message('', "Type /connect <server> [port] to connect, then /nick <my_nick> and /join <#channel>.");
      this.systemWindow.message('', "Alt+[0-9] switches windows.");
      this.status('hi!');
      this.connections = {};
    }

    IRC5.prototype.disconnect = function() {};

    IRC5.prototype.connect = function(server, port) {
      var c, conn, name, tries,
        _this = this;
      if (port == null) {
        port = 6667;
      }
      name = server;
      tries = 0;
      while (this.connections[name]) {
        name = server + ++tries;
      }
      c = new irc.IRC(server, port, {
        nick: this.default_nick
      });
      conn = this.connections[name] = {
        irc: c,
        name: name,
        windows: {}
      };
      c.on('connect', function() {
        return _this.onConnected(conn);
      });
      c.on('disconnect', function() {
        return _this.onDisconnected(conn);
      });
      c.on('message', function() {
        var args, target, type;
        target = arguments[0], type = arguments[1], args = 3 <= arguments.length ? __slice.call(arguments, 2) : [];
        return _this.onMessage.apply(_this, [conn, target, type].concat(__slice.call(args)));
      });
      c.on('joined', function(chan) {
        return _this.onJoined(conn, chan);
      });
      c.on('parted', function(chan) {
        return _this.onJoined(conn, chan);
      });
      c.connect();
      return this.systemWindow.conn = conn;
    };

    IRC5.prototype.onConnected = function(conn) {
      var chan, win, _ref, _results;
      this.systemWindow.message('', "Connected to " + conn.name);
      _ref = conn.windows;
      _results = [];
      for (chan in _ref) {
        win = _ref[chan];
        _results.push(win.message('', '(connected)', {
          type: 'system'
        }));
      }
      return _results;
    };

    IRC5.prototype.onDisconnected = function(conn) {
      var chan, win, _ref, _results;
      this.systemWindow.message('', "Disconnected from " + conn.name);
      _ref = conn.windows;
      _results = [];
      for (chan in _ref) {
        win = _ref[chan];
        _results.push(win.message('', '(disconnected)', {
          type: 'system'
        }));
      }
      return _results;
    };

    IRC5.prototype.onJoined = function(conn, chan) {
      var win;
      if (!(win = conn.windows[chan])) {
        win = this.makeWin(conn, chan);
      }
      return win.message('', '(You joined the channel.)', {
        type: 'system'
      });
    };

    IRC5.prototype.onParted = function(conn, chan) {
      var win;
      if (win = conn.windows[chan]) {
        return win.message('', '(You left the channel.)', {
          type: 'system'
        });
      }
    };

    IRC5.prototype.onMessage = function() {
      var args, conn, target, type, win;
      conn = arguments[0], target = arguments[1], type = arguments[2], args = 4 <= arguments.length ? __slice.call(arguments, 3) : [];
      if (target != null) {
        win = conn.windows[target];
        if (win) {
          return handlers[type].apply(win, args);
        } else {
          this.systemWindow.message(conn.name, "unknown message: " + target + "(" + type + "): " + (JSON.stringify(args)));
          return console.warn("unknown message to " + conn.name, target, type, args);
        }
      } else {
        return system_handlers[type].apply(this.systemWindow, [conn].concat(args));
      }
    };

    handlers = {
      join: function(nick) {
        return this.message('', "" + nick + " joined the channel.", {
          type: 'join'
        });
      },
      part: function(nick) {
        return this.message('', "" + nick + " left the channel.", {
          type: 'part'
        });
      },
      nick: function(from, to) {
        return this.message('', "" + from + " is now known as " + to + ".", {
          type: 'nick'
        });
      },
      quit: function(nick, reason) {
        return this.message('', "" + nick + " has quit: " + reason + ".", {
          type: 'quit'
        });
      },
      privmsg: function(from, msg) {
        var m;
        if (m = /^\u0001ACTION (.*)\u0001/.exec(msg)) {
          return this.message('', "" + from + " " + m[1], {
            type: 'privmsg action'
          });
        } else {
          return this.message(from, msg, {
            type: 'privmsg'
          });
        }
      }
    };

    system_handlers = {
      welcome: function(conn, msg) {
        return this.message(conn.name, msg, {
          type: 'welcome'
        });
      },
      unknown: function(conn, cmd) {
        return this.message(conn.name, cmd.command + ' ' + cmd.params.join(' '));
      },
      nickinuse: function(conn, oldnick, newnick, msg) {
        return this.message(conn.name, "Nickname " + oldnick + " already in use: " + msg);
      }
    };

    IRC5.prototype.makeWin = function(conn, chan) {
      var win;
      if (conn.windows[chan]) {
        throw new Error("we already have a window for that");
      }
      win = conn.windows[chan] = new Window(chan);
      win.conn = conn;
      win.target = chan;
      this.winList.push(win);
      return win;
    };

    IRC5.prototype.status = function(status) {
      var _ref;
      if (!status) {
        status = "[" + ((_ref = this.currentWindow.conn) != null ? _ref.irc.nick : void 0) + "] " + this.currentWindow.target;
      }
      return $('#status').text(status);
    };

    IRC5.prototype.switchToWindow = function(win) {
      if (this.currentWindow) {
        this.currentWindow.scroll = this.currentWindow.$container.scrollTop();
        this.currentWindow.wasScrolledDown = this.currentWindow.isScrolledDown();
        this.currentWindow.$container.detach();
      }
      this.$main.append(win.$container);
      if (win.wasScrolledDown) {
        win.scroll = win.$container[0].scrollHeight;
      }
      win.$container.scrollTop(win.scroll);
      this.currentWindow = win;
      return this.status();
    };

    commands = {
      join: function(chan) {
        var win;
        this.currentWindow.conn.irc.send('JOIN', chan);
        win = this.makeWin(this.currentWindow.conn, chan);
        return this.switchToWindow(win);
      },
      win: function(num) {
        num = parseInt(num);
        if (num < this.winList.length) {
          return this.switchToWindow(this.winList[num]);
        }
      },
      say: function() {
        var conn, msg, target, text;
        text = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        if ((target = this.currentWindow.target) && (conn = this.currentWindow.conn)) {
          msg = text.join(' ');
          this.onMessage(conn, target, 'privmsg', conn.irc.nick, msg);
          return conn.irc.send('PRIVMSG', target, msg);
        }
      },
      me: function() {
        var text;
        text = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
        return commands.say.call(this, '\u0001ACTION ' + text.join(' ') + '\u0001');
      },
      nick: function(newNick) {
        var conn;
        if (conn = this.currentWindow.conn) {
          chrome.storage.sync.set({
            nick: newNick
          });
          return conn.irc.send('NICK', newNick);
        }
      },
      connect: function(server, port) {
        return this.connect(server, port ? parseInt(port) : void 0);
      },
      dc: function() {
        var conn;
        if (conn = this.currentWindow.conn) {
          return conn.irc.socket.end();
        }
      },
      names: function() {
        var conn, k, names, target, v, _ref;
        if ((conn = this.currentWindow.conn) && (target = this.currentWindow.target) && (names = (_ref = conn.irc.channels[target]) != null ? _ref.names : void 0)) {
          names = ((function() {
            var _results;
            _results = [];
            for (k in names) {
              v = names[k];
              _results.push(v);
            }
            return _results;
          })()).sort();
          return this.currentWindow.message('', JSON.stringify(names));
        }
      }
    };

    IRC5.prototype.command = function(text) {
      var cmd, func;
      if (text[0] === '/') {
        cmd = text.slice(1).split(/\s+/);
        if (func = commands[cmd[0].toLowerCase()]) {
          return func.apply(this, cmd.slice(1));
        } else {
          return console.log("no such command");
        }
      } else {
        return commands.say.call(this, text);
      }
    };

    return IRC5;

  })();

  Window = (function() {

    function Window(name) {
      this.name = name;
      this.$container = $("<div id='chat-container'>");
      this.$messages = $("<div id='chat'>");
      this.$container.append(this.$messages);
    }

    Window.prototype.isScrolledDown = function() {
      var scrollBottom;
      scrollBottom = this.$container.scrollTop() + this.$container.height();
      return scrollBottom === this.$container[0].scrollHeight;
    };

    Window.prototype.message = function(from, msg, opts) {
      var e, extra_classes, scroll;
      if (opts == null) {
        opts = {};
      }
      scroll = this.isScrolledDown;
      e = escapeHTML;
      extra_classes = [opts.type];
      msg = display(msg);
      this.$messages.append($("<div class='message " + (extra_classes.join(' ')) + "'>\n  <div class='source'>" + (e(from)) + "</div>\n  <div class='text'>" + msg + "</div>\n</div>"));
      if (scroll) {
        return this.$container.scrollTop(this.$container[0].scrollHeight);
      }
    };

    return Window;

  })();

  irc5 = new IRC5;

  $cmd = $('#cmd');

  $cmd.focus();

  $(window).keydown(function(e) {
    var _ref;
    if (!(e.metaKey || e.ctrlKey)) {
      e.currentTarget = $('#cmd')[0];
      $cmd.focus();
    }
    if (e.altKey && (48 <= (_ref = e.which) && _ref <= 57)) {
      irc5.command("/win " + (e.which - 48));
      return e.preventDefault();
    }
  });

  $cmd.keydown(function(e) {
    var cmd;
    if (e.which === 13) {
      cmd = $cmd.val();
      if (cmd.length > 0) {
        $cmd.val('');
        return irc5.command(cmd);
      }
    }
  });

}).call(this);
